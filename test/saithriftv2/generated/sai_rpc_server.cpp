// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::sai;

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

extern sai_object_id_t switch_id;
sai_object_id_t switch_id;



void sai_thrift_parse_buffer(const std::string &thrift_buffer,
                             void *buffer) {
  /* not supported yet */
}


  // acl API helper functions

void sai_thrift_parse_acl_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_counter_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_range_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_RANGE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_range_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_RANGE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_TABLE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_TABLE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_TABLE_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_TABLE_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_member_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // bfd API helper functions

void sai_thrift_parse_bfd_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_BFD_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bfd_session_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BFD_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bfd_session_state_notification(const sai_thrift_bfd_session_state_notification_t &thrift_bfd_session_state_notification,
                                                     sai_bfd_session_state_notification_t *bfd_session_state_notification) {
  bfd_session_state_notification->bfd_session_id = thrift_bfd_session_state_notification.bfd_session_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  bfd_session_state_notification->session_state = thrift_bfd_session_state_notification.session_state;
#endif
}

  // bridge API helper functions

void sai_thrift_parse_bridge_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_BRIDGE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BRIDGE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bridge_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_BRIDGE_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BRIDGE_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // buffer API helper functions

void sai_thrift_parse_buffer_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_BUFFER_POOL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_pool_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BUFFER_POOL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_buffer_profile_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_BUFFER_PROFILE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_profile_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BUFFER_PROFILE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ingress_priority_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ingress_priority_group_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // counter API helper functions

void sai_thrift_parse_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_counter_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // debug_counter API helper functions

void sai_thrift_parse_debug_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DEBUG_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_debug_counter_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DEBUG_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // dtel API helper functions

void sai_thrift_parse_dtel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_event_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL_EVENT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_event_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL_EVENT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_int_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL_INT_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_int_session_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL_INT_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_queue_report_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_queue_report_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_report_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL_REPORT_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_report_session_attributes(sai_attribute_t *attr_list,
                                                       uint32_t attr_count,
                                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL_REPORT_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // fdb API helper functions

void sai_thrift_parse_fdb_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_FDB_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_FDB_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_flush_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_FDB_FLUSH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_flush_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_FDB_FLUSH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_entry(const sai_thrift_fdb_entry_t &thrift_fdb_entry,
                                sai_fdb_entry_t *fdb_entry) {
  fdb_entry->switch_id = thrift_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_fdb_entry.mac_address, &fdb_entry->mac_address);
  fdb_entry->bv_id = thrift_fdb_entry.bv_id;
}

void sai_thrift_parse_fdb_event_notification_data(const sai_thrift_fdb_event_notification_data_t &thrift_fdb_event_notification_data,
                                                  sai_fdb_event_notification_data_t *fdb_event_notification_data) {
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->event_type = thrift_fdb_event_notification_data.event_type;
#endif
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->fdb_entry = thrift_fdb_event_notification_data.fdb_entry;
#endif
  fdb_event_notification_data->attr_count = thrift_fdb_event_notification_data.attr_count;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->attr = thrift_fdb_event_notification_data.attr;
#endif
}

  // hash API helper functions

void sai_thrift_parse_fine_grained_hash_field_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fine_grained_hash_field_attributes(sai_attribute_t *attr_list,
                                                           uint32_t attr_count,
                                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hash_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HASH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hash_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HASH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // hostif API helper functions

void sai_thrift_parse_hostif_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_packet_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF_PACKET, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_packet_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF_PACKET, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_table_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_table_entry_attributes(sai_attribute_t *attr_list,
                                                      uint32_t attr_count,
                                                      std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF_TRAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF_TRAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_group_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_user_defined_trap_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_user_defined_trap_attributes(sai_attribute_t *attr_list,
                                                            uint32_t attr_count,
                                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // ipmc API helper functions

void sai_thrift_parse_ipmc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_IPMC_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_entry_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_IPMC_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_entry(const sai_thrift_ipmc_entry_t &thrift_ipmc_entry,
                                 sai_ipmc_entry_t *ipmc_entry) {
  ipmc_entry->switch_id = thrift_ipmc_entry.switch_id;
  ipmc_entry->vr_id = thrift_ipmc_entry.vr_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  ipmc_entry->type = thrift_ipmc_entry.type;
#endif
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.destination, &ipmc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.source, &ipmc_entry->source);
}

  // ipmc_group API helper functions

void sai_thrift_parse_ipmc_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_IPMC_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_IPMC_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_member_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // isolation_group API helper functions

void sai_thrift_parse_isolation_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ISOLATION_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ISOLATION_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_isolation_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_member_attributes(sai_attribute_t *attr_list,
                                                          uint32_t attr_count,
                                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // l2mc API helper functions

void sai_thrift_parse_l2mc_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_L2MC_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_entry_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_L2MC_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_entry(const sai_thrift_l2mc_entry_t &thrift_l2mc_entry,
                                 sai_l2mc_entry_t *l2mc_entry) {
  l2mc_entry->switch_id = thrift_l2mc_entry.switch_id;
  l2mc_entry->bv_id = thrift_l2mc_entry.bv_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  l2mc_entry->type = thrift_l2mc_entry.type;
#endif
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.destination, &l2mc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.source, &l2mc_entry->source);
}

  // l2mc_group API helper functions

void sai_thrift_parse_l2mc_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_L2MC_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_L2MC_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                   sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_member_attributes(sai_attribute_t *attr_list,
                                                     uint32_t attr_count,
                                                     std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // lag API helper functions

void sai_thrift_parse_lag_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_LAG, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_LAG, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_lag_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_LAG_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_member_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_LAG_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // macsec API helper functions

void sai_thrift_parse_macsec_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MACSEC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_flow_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MACSEC_FLOW, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_flow_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC_FLOW, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MACSEC_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sa_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MACSEC_SA, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sa_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC_SA, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sc_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MACSEC_SC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sc_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC_SC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // mcast_fdb API helper functions

void sai_thrift_parse_mcast_fdb_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MCAST_FDB_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mcast_fdb_entry_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MCAST_FDB_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry,
                                      sai_mcast_fdb_entry_t *mcast_fdb_entry) {
  mcast_fdb_entry->switch_id = thrift_mcast_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_mcast_fdb_entry.mac_address, &mcast_fdb_entry->mac_address);
  mcast_fdb_entry->bv_id = thrift_mcast_fdb_entry.bv_id;
}

  // mirror API helper functions

void sai_thrift_parse_mirror_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_MIRROR_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mirror_session_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MIRROR_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // mpls API helper functions

void sai_thrift_parse_inseg_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_INSEG_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_inseg_entry_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_INSEG_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_inseg_entry(const sai_thrift_inseg_entry_t &thrift_inseg_entry,
                                  sai_inseg_entry_t *inseg_entry) {
  inseg_entry->switch_id = thrift_inseg_entry.switch_id;
  inseg_entry->label = thrift_inseg_entry.label;
}

  // nat API helper functions

void sai_thrift_parse_nat_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NAT_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_entry_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NAT_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_zone_counter_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NAT_ZONE_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_zone_counter_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NAT_ZONE_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_entry_key(const sai_thrift_nat_entry_key_t &thrift_nat_entry_key,
                                    sai_nat_entry_key_t *nat_entry_key) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.src_ip, &nat_entry_key->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.dst_ip, &nat_entry_key->dst_ip);
  nat_entry_key->proto = thrift_nat_entry_key.proto;
  nat_entry_key->l4_src_port = thrift_nat_entry_key.l4_src_port;
  nat_entry_key->l4_dst_port = thrift_nat_entry_key.l4_dst_port;
}

void sai_thrift_parse_nat_entry_mask(const sai_thrift_nat_entry_mask_t &thrift_nat_entry_mask,
                                     sai_nat_entry_mask_t *nat_entry_mask) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.src_ip, &nat_entry_mask->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.dst_ip, &nat_entry_mask->dst_ip);
  nat_entry_mask->proto = thrift_nat_entry_mask.proto;
  nat_entry_mask->l4_src_port = thrift_nat_entry_mask.l4_src_port;
  nat_entry_mask->l4_dst_port = thrift_nat_entry_mask.l4_dst_port;
}

void sai_thrift_parse_nat_entry_data(const sai_thrift_nat_entry_data_t &thrift_nat_entry_data,
                                     sai_nat_entry_data_t *nat_entry_data) {
  // using existing converter
  sai_thrift_parse_nat_entry_key(thrift_nat_entry_data.key, &nat_entry_data->key);
  // using existing converter
  sai_thrift_parse_nat_entry_mask(thrift_nat_entry_data.mask, &nat_entry_data->mask);
}

void sai_thrift_parse_nat_entry(const sai_thrift_nat_entry_t &thrift_nat_entry,
                                sai_nat_entry_t *nat_entry) {
  nat_entry->switch_id = thrift_nat_entry.switch_id;
  nat_entry->vr_id = thrift_nat_entry.vr_id;
  // using manual converter
  sai_thrift_nat_type_t_parse(thrift_nat_entry.nat_type, &nat_entry->nat_type);
  // using existing converter
  sai_thrift_parse_nat_entry_data(thrift_nat_entry.data, &nat_entry->data);
}

  // neighbor API helper functions

void sai_thrift_parse_neighbor_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NEIGHBOR_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_neighbor_entry_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NEIGHBOR_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_neighbor_entry(const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
                                     sai_neighbor_entry_t *neighbor_entry) {
  neighbor_entry->switch_id = thrift_neighbor_entry.switch_id;
  neighbor_entry->rif_id = thrift_neighbor_entry.rif_id;
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_neighbor_entry.ip_address, &neighbor_entry->ip_address);
}

  // next_hop API helper functions

void sai_thrift_parse_next_hop_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NEXT_HOP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_attributes(sai_attribute_t *attr_list,
                                            uint32_t attr_count,
                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NEXT_HOP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // next_hop_group API helper functions

void sai_thrift_parse_next_hop_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NEXT_HOP_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NEXT_HOP_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_next_hop_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_member_attributes(sai_attribute_t *attr_list,
                                                         uint32_t attr_count,
                                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // policer API helper functions

void sai_thrift_parse_policer_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_POLICER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_policer_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_POLICER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // port API helper functions

void sai_thrift_parse_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_connector_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_PORT_CONNECTOR, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_connector_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_PORT_CONNECTOR, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_PORT_POOL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_pool_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_PORT_POOL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_serdes_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_PORT_SERDES, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_serdes_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_PORT_SERDES, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_oper_status_notification(const sai_thrift_port_oper_status_notification_t &thrift_port_oper_status_notification,
                                                    sai_port_oper_status_notification_t *port_oper_status_notification) {
  port_oper_status_notification->port_id = thrift_port_oper_status_notification.port_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  port_oper_status_notification->port_state = thrift_port_oper_status_notification.port_state;
#endif
}

  // qos_map API helper functions

void sai_thrift_parse_qos_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_QOS_MAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_qos_map_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_QOS_MAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // queue API helper functions

void sai_thrift_parse_queue_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                       sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_QUEUE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_queue_attributes(sai_attribute_t *attr_list,
                                         uint32_t attr_count,
                                         std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_QUEUE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_queue_deadlock_notification_data(const sai_thrift_queue_deadlock_notification_data_t &thrift_queue_deadlock_notification_data,
                                                       sai_queue_deadlock_notification_data_t *queue_deadlock_notification_data) {
  queue_deadlock_notification_data->queue_id = thrift_queue_deadlock_notification_data.queue_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  queue_deadlock_notification_data->event = thrift_queue_deadlock_notification_data.event;
#endif
  queue_deadlock_notification_data->app_managed_recovery = thrift_queue_deadlock_notification_data.app_managed_recovery;
}

  // route API helper functions

void sai_thrift_parse_route_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ROUTE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_route_entry_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ROUTE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_route_entry(const sai_thrift_route_entry_t &thrift_route_entry,
                                  sai_route_entry_t *route_entry) {
  route_entry->switch_id = thrift_route_entry.switch_id;
  route_entry->vr_id = thrift_route_entry.vr_id;
  // using manual converter
  sai_thrift_ip_prefix_t_parse(thrift_route_entry.destination, &route_entry->destination);
}

  // router_interface API helper functions

void sai_thrift_parse_router_interface_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_ROUTER_INTERFACE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_router_interface_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_ROUTER_INTERFACE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // rpf_group API helper functions

void sai_thrift_parse_rpf_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_RPF_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_RPF_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_rpf_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_RPF_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_member_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_RPF_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // samplepacket API helper functions

void sai_thrift_parse_samplepacket_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SAMPLEPACKET, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_samplepacket_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SAMPLEPACKET, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // scheduler API helper functions

void sai_thrift_parse_scheduler_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SCHEDULER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SCHEDULER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // scheduler_group API helper functions

void sai_thrift_parse_scheduler_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                 sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SCHEDULER_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_group_attributes(sai_attribute_t *attr_list,
                                                   uint32_t attr_count,
                                                   std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SCHEDULER_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // segmentroute API helper functions

void sai_thrift_parse_segmentroute_sidlist_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SEGMENTROUTE_SIDLIST, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_segmentroute_sidlist_attributes(sai_attribute_t *attr_list,
                                                        uint32_t attr_count,
                                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SEGMENTROUTE_SIDLIST, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // stp API helper functions

void sai_thrift_parse_stp_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_STP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_STP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_stp_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                          sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_STP_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_port_attributes(sai_attribute_t *attr_list,
                                            uint32_t attr_count,
                                            std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_STP_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // switch API helper functions

void sai_thrift_parse_switch_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SWITCH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SWITCH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_switch_tunnel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SWITCH_TUNNEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_tunnel_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SWITCH_TUNNEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // system_port API helper functions

void sai_thrift_parse_system_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_SYSTEM_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_system_port_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SYSTEM_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // tam API helper functions

void sai_thrift_parse_tam_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_collector_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_COLLECTOR, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_collector_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_COLLECTOR, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_EVENT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_EVENT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_action_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_EVENT_ACTION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_action_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_EVENT_ACTION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_threshold_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_threshold_attributes(sai_attribute_t *attr_list,
                                                       uint32_t attr_count,
                                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_int_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_INT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_int_attributes(sai_attribute_t *attr_list,
                                           uint32_t attr_count,
                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_INT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_math_func_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_MATH_FUNC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_math_func_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_MATH_FUNC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_report_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_REPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_report_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_REPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_tel_type_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                              sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_TEL_TYPE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_tel_type_attributes(sai_attribute_t *attr_list,
                                                uint32_t attr_count,
                                                std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_TEL_TYPE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_telemetry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_TELEMETRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_telemetry_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_TELEMETRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_transport_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                               sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM_TRANSPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_transport_attributes(sai_attribute_t *attr_list,
                                                 uint32_t attr_count,
                                                 std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM_TRANSPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // tunnel API helper functions

void sai_thrift_parse_tunnel_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                        sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TUNNEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_attributes(sai_attribute_t *attr_list,
                                          uint32_t attr_count,
                                          std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TUNNEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                            sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TUNNEL_MAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_attributes(sai_attribute_t *attr_list,
                                              uint32_t attr_count,
                                              std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TUNNEL_MAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                  sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_entry_attributes(sai_attribute_t *attr_list,
                                                    uint32_t attr_count,
                                                    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_term_table_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                         sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_term_table_entry_attributes(sai_attribute_t *attr_list,
                                                           uint32_t attr_count,
                                                           std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // udf API helper functions

void sai_thrift_parse_udf_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                     sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_UDF, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_attributes(sai_attribute_t *attr_list,
                                       uint32_t attr_count,
                                       std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_UDF, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_UDF_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_group_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_UDF_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_match_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                           sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_UDF_MATCH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_match_attributes(sai_attribute_t *attr_list,
                                             uint32_t attr_count,
                                             std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_UDF_MATCH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // virtual_router API helper functions

void sai_thrift_parse_virtual_router_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                                sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_VIRTUAL_ROUTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_virtual_router_attributes(sai_attribute_t *attr_list,
                                                  uint32_t attr_count,
                                                  std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_VIRTUAL_ROUTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // vlan API helper functions

void sai_thrift_parse_vlan_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_VLAN, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_VLAN, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_vlan_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                             sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_VLAN_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_member_attributes(sai_attribute_t *attr_list,
                                               uint32_t attr_count,
                                               std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_VLAN_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

  // wred API helper functions

void sai_thrift_parse_wred_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
                                      sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
      return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_WRED, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_wred_attributes(sai_attribute_t *attr_list,
                                        uint32_t attr_count,
                                        std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_WRED, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}


class sai_rpcHandler : virtual public sai_rpcIf {
 public:
  sai_rpcHandler() {
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_table(&acl_table_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_oid_out;
  }

  void sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_table((sai_object_id_t)acl_table_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_attribute(const sai_thrift_object_id_t acl_table_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_table_attribute((sai_object_id_t)acl_table_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_table_attribute((sai_object_id_t)acl_table_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_entry_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_entry(&acl_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_entry_oid_out;
  }

  void sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_entry((sai_object_id_t)acl_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_entry_attribute(const sai_thrift_object_id_t acl_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_entry_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_entry_attribute((sai_object_id_t)acl_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_entry_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_entry_attribute((sai_object_id_t)acl_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_counter_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_counter(&acl_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_counter_oid_out;
  }

  void sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_counter((sai_object_id_t)acl_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_counter_attribute(const sai_thrift_object_id_t acl_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_counter_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_counter_attribute((sai_object_id_t)acl_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_counter_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_counter_attribute((sai_object_id_t)acl_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_range_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_range_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_range(&acl_range_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_range_oid_out;
  }

  void sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_range((sai_object_id_t)acl_range_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_range_attribute(const sai_thrift_object_id_t acl_range_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_range_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_range_attribute((sai_object_id_t)acl_range_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_range_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_range_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_range_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_range_attribute((sai_object_id_t)acl_range_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_range_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_table_group(&acl_table_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_group_oid_out;
  }

  void sai_thrift_remove_acl_table_group(const sai_thrift_object_id_t acl_table_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_table_group((sai_object_id_t)acl_table_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_attribute(const sai_thrift_object_id_t acl_table_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_group_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_table_group_attribute((sai_object_id_t)acl_table_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_group_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_table_group_attribute((sai_object_id_t)acl_table_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_member_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_table_group_member(&acl_table_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return acl_table_group_member_oid_out;
  }

  void sai_thrift_remove_acl_table_group_member(const sai_thrift_object_id_t acl_table_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_table_group_member((sai_object_id_t)acl_table_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_member_attribute(const sai_thrift_object_id_t acl_table_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_acl_table_group_member_attributes(attr_vec, &sai_attr);

    status = acl_api->set_acl_table_group_member_attribute((sai_object_id_t)acl_table_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_acl_table_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t acl_table_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_acl_table_group_member_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_table_group_member_attribute((sai_object_id_t)acl_table_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bfd_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bfd_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bfd_session_attributes(attr_list, sai_attr_list);

    status = bfd_api->create_bfd_session(&bfd_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bfd_session_oid_out;
  }

  void sai_thrift_remove_bfd_session(const sai_thrift_object_id_t bfd_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bfd_api->remove_bfd_session((sai_object_id_t)bfd_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bfd_session_attribute(const sai_thrift_object_id_t bfd_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bfd_session_attributes(attr_vec, &sai_attr);

    status = bfd_api->set_bfd_session_attribute((sai_object_id_t)bfd_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bfd_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bfd_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bfd_session_attributes(attr_list_vec, sai_attr_list);

    status = bfd_api->get_bfd_session_attribute((sai_object_id_t)bfd_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bfd_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bfd_session_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bfd_api->get_bfd_session_stats((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bfd_session_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bfd_api->get_bfd_session_stats_ext((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bfd_session_stats(const sai_thrift_object_id_t bfd_session_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bfd_api->clear_bfd_session_stats((sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_port_attributes(attr_list, sai_attr_list);

    status = bridge_api->create_bridge_port(&bridge_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bridge_port_oid_out;
  }

  void sai_thrift_remove_bridge_port(const sai_thrift_object_id_t bridge_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bridge_api->remove_bridge_port((sai_object_id_t)bridge_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_port_attribute(const sai_thrift_object_id_t bridge_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bridge_port_attributes(attr_vec, &sai_attr);

    status = bridge_api->set_bridge_port_attribute((sai_object_id_t)bridge_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bridge_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bridge_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bridge_port_attributes(attr_list_vec, sai_attr_list);

    status = bridge_api->get_bridge_port_attribute((sai_object_id_t)bridge_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_port_stats((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_port_stats_ext((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_port_stats(const sai_thrift_object_id_t bridge_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->clear_bridge_port_stats((sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_oid_out = SAI_NULL_OBJECT_ID;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_attributes(attr_list, sai_attr_list);

    status = bridge_api->create_bridge(&bridge_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return bridge_oid_out;
  }

  void sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bridge_api->remove_bridge((sai_object_id_t)bridge_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_bridge_attributes(attr_vec, &sai_attr);

    status = bridge_api->set_bridge_attribute((sai_object_id_t)bridge_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_bridge_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t bridge_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_bridge_attributes(attr_list_vec, sai_attr_list);

    status = bridge_api->get_bridge_attribute((sai_object_id_t)bridge_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_stats((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_stats_ext((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_stats(const sai_thrift_object_id_t bridge_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->clear_bridge_stats((sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ingress_priority_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ingress_priority_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ingress_priority_group_attributes(attr_list, sai_attr_list);

    status = buffer_api->create_ingress_priority_group(&ingress_priority_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ingress_priority_group_oid_out;
  }

  void sai_thrift_remove_ingress_priority_group(const sai_thrift_object_id_t ingress_priority_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = buffer_api->remove_ingress_priority_group((sai_object_id_t)ingress_priority_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ingress_priority_group_attribute(const sai_thrift_object_id_t ingress_priority_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ingress_priority_group_attributes(attr_vec, &sai_attr);

    status = buffer_api->set_ingress_priority_group_attribute((sai_object_id_t)ingress_priority_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ingress_priority_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ingress_priority_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ingress_priority_group_attributes(attr_list_vec, sai_attr_list);

    status = buffer_api->get_ingress_priority_group_attribute((sai_object_id_t)ingress_priority_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ingress_priority_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_ingress_priority_group_stats((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_ingress_priority_group_stats_ext((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ingress_priority_group_stats(const sai_thrift_object_id_t ingress_priority_group_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->clear_ingress_priority_group_stats((sai_object_id_t)ingress_priority_group_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_pool(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_pool_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_pool_attributes(attr_list, sai_attr_list);

    status = buffer_api->create_buffer_pool(&buffer_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return buffer_pool_oid_out;
  }

  void sai_thrift_remove_buffer_pool(const sai_thrift_object_id_t buffer_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = buffer_api->remove_buffer_pool((sai_object_id_t)buffer_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_pool_attribute(const sai_thrift_object_id_t buffer_pool_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_buffer_pool_attributes(attr_vec, &sai_attr);

    status = buffer_api->set_buffer_pool_attribute((sai_object_id_t)buffer_pool_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_buffer_pool_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t buffer_pool_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_buffer_pool_attributes(attr_list_vec, sai_attr_list);

    status = buffer_api->get_buffer_pool_attribute((sai_object_id_t)buffer_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_pool_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_buffer_pool_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_buffer_pool_stats((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_buffer_pool_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_buffer_pool_stats_ext((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_buffer_pool_stats(const sai_thrift_object_id_t buffer_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->clear_buffer_pool_stats((sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_profile_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_profile_attributes(attr_list, sai_attr_list);

    status = buffer_api->create_buffer_profile(&buffer_profile_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return buffer_profile_oid_out;
  }

  void sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = buffer_api->remove_buffer_profile((sai_object_id_t)buffer_profile_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_profile_attribute(const sai_thrift_object_id_t buffer_profile_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_buffer_profile_attributes(attr_vec, &sai_attr);

    status = buffer_api->set_buffer_profile_attribute((sai_object_id_t)buffer_profile_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_buffer_profile_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t buffer_profile_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_buffer_profile_attributes(attr_list_vec, sai_attr_list);

    status = buffer_api->get_buffer_profile_attribute((sai_object_id_t)buffer_profile_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_profile_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_counter_attributes(attr_list, sai_attr_list);

    status = counter_api->create_counter(&counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return counter_oid_out;
  }

  void sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = counter_api->remove_counter((sai_object_id_t)counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_counter_attribute(const sai_thrift_object_id_t counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_counter_attributes(attr_vec, &sai_attr);

    status = counter_api->set_counter_attribute((sai_object_id_t)counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_counter_attributes(attr_list_vec, sai_attr_list);

    status = counter_api->get_counter_attribute((sai_object_id_t)counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_counter_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = counter_api->get_counter_stats((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_counter_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = counter_api->get_counter_stats_ext((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_counter_stats(const sai_thrift_object_id_t counter_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = counter_api->clear_counter_stats((sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_debug_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t debug_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_debug_counter_attributes(attr_list, sai_attr_list);

    status = debug_counter_api->create_debug_counter(&debug_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return debug_counter_oid_out;
  }

  void sai_thrift_remove_debug_counter(const sai_thrift_object_id_t debug_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = debug_counter_api->remove_debug_counter((sai_object_id_t)debug_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_debug_counter_attribute(const sai_thrift_object_id_t debug_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_debug_counter_attributes(attr_vec, &sai_attr);

    status = debug_counter_api->set_debug_counter_attribute((sai_object_id_t)debug_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_debug_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t debug_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_debug_counter_attributes(attr_list_vec, sai_attr_list);

    status = debug_counter_api->get_debug_counter_attribute((sai_object_id_t)debug_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_debug_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel(&dtel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_oid_out;
  }

  void sai_thrift_remove_dtel(const sai_thrift_object_id_t dtel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel((sai_object_id_t)dtel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_attribute(const sai_thrift_object_id_t dtel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_attributes(attr_vec, &sai_attr);

    status = dtel_api->set_dtel_attribute((sai_object_id_t)dtel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_attribute((sai_object_id_t)dtel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_queue_report(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_queue_report_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_queue_report_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_queue_report(&dtel_queue_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_queue_report_oid_out;
  }

  void sai_thrift_remove_dtel_queue_report(const sai_thrift_object_id_t dtel_queue_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_queue_report((sai_object_id_t)dtel_queue_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_queue_report_attribute(const sai_thrift_object_id_t dtel_queue_report_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_queue_report_attributes(attr_vec, &sai_attr);

    status = dtel_api->set_dtel_queue_report_attribute((sai_object_id_t)dtel_queue_report_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_queue_report_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_queue_report_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_queue_report_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_queue_report_attribute((sai_object_id_t)dtel_queue_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_queue_report_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_int_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_int_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_int_session_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_int_session(&dtel_int_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_int_session_oid_out;
  }

  void sai_thrift_remove_dtel_int_session(const sai_thrift_object_id_t dtel_int_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_int_session((sai_object_id_t)dtel_int_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_int_session_attribute(const sai_thrift_object_id_t dtel_int_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_int_session_attributes(attr_vec, &sai_attr);

    status = dtel_api->set_dtel_int_session_attribute((sai_object_id_t)dtel_int_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_int_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_int_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_int_session_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_int_session_attribute((sai_object_id_t)dtel_int_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_int_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_report_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_report_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_report_session_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_report_session(&dtel_report_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_report_session_oid_out;
  }

  void sai_thrift_remove_dtel_report_session(const sai_thrift_object_id_t dtel_report_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_report_session((sai_object_id_t)dtel_report_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_report_session_attribute(const sai_thrift_object_id_t dtel_report_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_report_session_attributes(attr_vec, &sai_attr);

    status = dtel_api->set_dtel_report_session_attribute((sai_object_id_t)dtel_report_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_report_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_report_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_report_session_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_report_session_attribute((sai_object_id_t)dtel_report_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_report_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_event(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_event_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_event_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_event(&dtel_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return dtel_event_oid_out;
  }

  void sai_thrift_remove_dtel_event(const sai_thrift_object_id_t dtel_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_event((sai_object_id_t)dtel_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_event_attribute(const sai_thrift_object_id_t dtel_event_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_dtel_event_attributes(attr_vec, &sai_attr);

    status = dtel_api->set_dtel_event_attribute((sai_object_id_t)dtel_event_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_dtel_event_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t dtel_event_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_dtel_event_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_event_attribute((sai_object_id_t)dtel_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_event_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fdb_entry_attributes(attr_list, sai_attr_list);

    status = fdb_api->create_fdb_entry(&sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_fdb_entry(const sai_thrift_fdb_entry_t& fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    status = fdb_api->remove_fdb_entry(&sai_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fdb_entry_attribute(const sai_thrift_fdb_entry_t& fdb_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_attribute_t sai_attr;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_fdb_entry_attributes(attr_vec, &sai_attr);

    status = fdb_api->set_fdb_entry_attribute(&sai_fdb_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_fdb_entry_t& fdb_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    status = fdb_api->get_fdb_entry_attribute(&sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fdb_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }

    sai_thrift_parse_fdb_flush_attributes(attr_list, sai_attr_list);

    status = fdb_api->flush_fdb_entries(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_fdb_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_fdb_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_fdb_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_fdb_entry_t> & fdb_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_fine_grained_hash_field(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t fine_grained_hash_field_oid_out = SAI_NULL_OBJECT_ID;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list, sai_attr_list);

    status = hash_api->create_fine_grained_hash_field(&fine_grained_hash_field_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return fine_grained_hash_field_oid_out;
  }

  void sai_thrift_remove_fine_grained_hash_field(const sai_thrift_object_id_t fine_grained_hash_field_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hash_api->remove_fine_grained_hash_field((sai_object_id_t)fine_grained_hash_field_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fine_grained_hash_field_attribute(const sai_thrift_object_id_t fine_grained_hash_field_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_vec, &sai_attr);

    status = hash_api->set_fine_grained_hash_field_attribute((sai_object_id_t)fine_grained_hash_field_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_fine_grained_hash_field_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t fine_grained_hash_field_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list_vec, sai_attr_list);

    status = hash_api->get_fine_grained_hash_field_attribute((sai_object_id_t)fine_grained_hash_field_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fine_grained_hash_field_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hash(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hash_oid_out = SAI_NULL_OBJECT_ID;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hash_attributes(attr_list, sai_attr_list);

    status = hash_api->create_hash(&hash_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hash_oid_out;
  }

  void sai_thrift_remove_hash(const sai_thrift_object_id_t hash_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hash_api->remove_hash((sai_object_id_t)hash_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hash_attribute(const sai_thrift_object_id_t hash_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hash_attributes(attr_vec, &sai_attr);

    status = hash_api->set_hash_attribute((sai_object_id_t)hash_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hash_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hash_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hash_attributes(attr_list_vec, sai_attr_list);

    status = hash_api->get_hash_attribute((sai_object_id_t)hash_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hash_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_trap_group(&hostif_trap_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_trap_group_oid_out;
  }

  void sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t hostif_trap_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_trap_group((sai_object_id_t)hostif_trap_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_group_attribute(const sai_thrift_object_id_t hostif_trap_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_trap_group_attributes(attr_vec, &sai_attr);

    status = hostif_api->set_hostif_trap_group_attribute((sai_object_id_t)hostif_trap_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_trap_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_trap_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_trap_group_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_trap_group_attribute((sai_object_id_t)hostif_trap_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_trap(&hostif_trap_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_trap_oid_out;
  }

  void sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t hostif_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_trap((sai_object_id_t)hostif_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_attribute(const sai_thrift_object_id_t hostif_trap_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_trap_attributes(attr_vec, &sai_attr);

    status = hostif_api->set_hostif_trap_attribute((sai_object_id_t)hostif_trap_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_trap_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_trap_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_trap_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_trap_attribute((sai_object_id_t)hostif_trap_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_user_defined_trap(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_user_defined_trap_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_user_defined_trap(&hostif_user_defined_trap_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_user_defined_trap_oid_out;
  }

  void sai_thrift_remove_hostif_user_defined_trap(const sai_thrift_object_id_t hostif_user_defined_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_user_defined_trap((sai_object_id_t)hostif_user_defined_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_user_defined_trap_attribute(const sai_thrift_object_id_t hostif_user_defined_trap_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_vec, &sai_attr);

    status = hostif_api->set_hostif_user_defined_trap_attribute((sai_object_id_t)hostif_user_defined_trap_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_user_defined_trap_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_user_defined_trap_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_user_defined_trap_attribute((sai_object_id_t)hostif_user_defined_trap_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_user_defined_trap_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif(&hostif_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_oid_out;
  }

  void sai_thrift_remove_hostif(const sai_thrift_object_id_t hostif_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif((sai_object_id_t)hostif_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t hostif_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_attributes(attr_vec, &sai_attr);

    status = hostif_api->set_hostif_attribute((sai_object_id_t)hostif_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_attribute((sai_object_id_t)hostif_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_table_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_table_entry_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_table_entry(&hostif_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return hostif_table_entry_oid_out;
  }

  void sai_thrift_remove_hostif_table_entry(const sai_thrift_object_id_t hostif_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_table_entry((sai_object_id_t)hostif_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_table_entry_attribute(const sai_thrift_object_id_t hostif_table_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_hostif_table_entry_attributes(attr_vec, &sai_attr);

    status = hostif_api->set_hostif_table_entry_attribute((sai_object_id_t)hostif_table_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_hostif_table_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t hostif_table_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_hostif_table_entry_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_table_entry_attribute((sai_object_id_t)hostif_table_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_table_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_size_t sai_thrift_recv_hostif_packet(const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::string& buffer, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return 0ULL;
  }

  void sai_thrift_send_hostif_packet(const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::string& buffer, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_allocate_hostif_packet(std::string& buffer_out, const sai_thrift_object_id_t hostif_oid, const sai_thrift_size_t buffer_size, const std::vector<sai_thrift_attribute_t> & attr_list) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_free_hostif_packet(std::string& buffer_out, const sai_thrift_object_id_t hostif_oid, const std::string& buffer) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_ipmc_entry(const sai_thrift_ipmc_entry_t& ipmc_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_entry_attributes(attr_list, sai_attr_list);

    status = ipmc_api->create_ipmc_entry(&sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t& ipmc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    status = ipmc_api->remove_ipmc_entry(&sai_ipmc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_entry_attribute(const sai_thrift_ipmc_entry_t& ipmc_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_attribute_t sai_attr;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_entry_attributes(attr_vec, &sai_attr);

    status = ipmc_api->set_ipmc_entry_attribute(&sai_ipmc_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_ipmc_entry_t& ipmc_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_entry_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_api->get_ipmc_entry_attribute(&sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_attributes(attr_list, sai_attr_list);

    status = ipmc_group_api->create_ipmc_group(&ipmc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipmc_group_oid_out;
  }

  void sai_thrift_remove_ipmc_group(const sai_thrift_object_id_t ipmc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipmc_group_api->remove_ipmc_group((sai_object_id_t)ipmc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_attribute(const sai_thrift_object_id_t ipmc_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_group_attributes(attr_vec, &sai_attr);

    status = ipmc_group_api->set_ipmc_group_attribute((sai_object_id_t)ipmc_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipmc_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_group_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_group_api->get_ipmc_group_attribute((sai_object_id_t)ipmc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_member_attributes(attr_list, sai_attr_list);

    status = ipmc_group_api->create_ipmc_group_member(&ipmc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return ipmc_group_member_oid_out;
  }

  void sai_thrift_remove_ipmc_group_member(const sai_thrift_object_id_t ipmc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipmc_group_api->remove_ipmc_group_member((sai_object_id_t)ipmc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_member_attribute(const sai_thrift_object_id_t ipmc_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_ipmc_group_member_attributes(attr_vec, &sai_attr);

    status = ipmc_group_api->set_ipmc_group_member_attribute((sai_object_id_t)ipmc_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_ipmc_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t ipmc_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_ipmc_group_member_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_group_api->get_ipmc_group_member_attribute((sai_object_id_t)ipmc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_attributes(attr_list, sai_attr_list);

    status = isolation_group_api->create_isolation_group(&isolation_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return isolation_group_oid_out;
  }

  void sai_thrift_remove_isolation_group(const sai_thrift_object_id_t isolation_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = isolation_group_api->remove_isolation_group((sai_object_id_t)isolation_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_attribute(const sai_thrift_object_id_t isolation_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_isolation_group_attributes(attr_vec, &sai_attr);

    status = isolation_group_api->set_isolation_group_attribute((sai_object_id_t)isolation_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_isolation_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t isolation_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_isolation_group_attributes(attr_list_vec, sai_attr_list);

    status = isolation_group_api->get_isolation_group_attribute((sai_object_id_t)isolation_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_member_attributes(attr_list, sai_attr_list);

    status = isolation_group_api->create_isolation_group_member(&isolation_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return isolation_group_member_oid_out;
  }

  void sai_thrift_remove_isolation_group_member(const sai_thrift_object_id_t isolation_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = isolation_group_api->remove_isolation_group_member((sai_object_id_t)isolation_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_member_attribute(const sai_thrift_object_id_t isolation_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_isolation_group_member_attributes(attr_vec, &sai_attr);

    status = isolation_group_api->set_isolation_group_member_attribute((sai_object_id_t)isolation_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_isolation_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t isolation_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status = sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_isolation_group_member_attributes(attr_list_vec, sai_attr_list);

    status = isolation_group_api->get_isolation_group_member_attribute((sai_object_id_t)isolation_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_l2mc_entry(const sai_thrift_l2mc_entry_t& l2mc_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_entry_attributes(attr_list, sai_attr_list);

    status = l2mc_api->create_l2mc_entry(&sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t& l2mc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    status = l2mc_api->remove_l2mc_entry(&sai_l2mc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_entry_attribute(const sai_thrift_l2mc_entry_t& l2mc_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_attribute_t sai_attr;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_entry_attributes(attr_vec, &sai_attr);

    status = l2mc_api->set_l2mc_entry_attribute(&sai_l2mc_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_l2mc_entry_t& l2mc_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_entry_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_api->get_l2mc_entry_attribute(&sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_attributes(attr_list, sai_attr_list);

    status = l2mc_group_api->create_l2mc_group(&l2mc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return l2mc_group_oid_out;
  }

  void sai_thrift_remove_l2mc_group(const sai_thrift_object_id_t l2mc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = l2mc_group_api->remove_l2mc_group((sai_object_id_t)l2mc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_attribute(const sai_thrift_object_id_t l2mc_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_group_attributes(attr_vec, &sai_attr);

    status = l2mc_group_api->set_l2mc_group_attribute((sai_object_id_t)l2mc_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t l2mc_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_group_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_group_api->get_l2mc_group_attribute((sai_object_id_t)l2mc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_member_attributes(attr_list, sai_attr_list);

    status = l2mc_group_api->create_l2mc_group_member(&l2mc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return l2mc_group_member_oid_out;
  }

  void sai_thrift_remove_l2mc_group_member(const sai_thrift_object_id_t l2mc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = l2mc_group_api->remove_l2mc_group_member((sai_object_id_t)l2mc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_member_attribute(const sai_thrift_object_id_t l2mc_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_l2mc_group_member_attributes(attr_vec, &sai_attr);

    status = l2mc_group_api->set_l2mc_group_member_attribute((sai_object_id_t)l2mc_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_l2mc_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t l2mc_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_l2mc_group_member_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_group_api->get_l2mc_group_member_attribute((sai_object_id_t)l2mc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_oid_out = SAI_NULL_OBJECT_ID;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_attributes(attr_list, sai_attr_list);

    status = lag_api->create_lag(&lag_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return lag_oid_out;
  }

  void sai_thrift_remove_lag(const sai_thrift_object_id_t lag_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = lag_api->remove_lag((sai_object_id_t)lag_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_lag_attributes(attr_vec, &sai_attr);

    status = lag_api->set_lag_attribute((sai_object_id_t)lag_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_lag_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t lag_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_lag_attributes(attr_list_vec, sai_attr_list);

    status = lag_api->get_lag_attribute((sai_object_id_t)lag_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_member_attributes(attr_list, sai_attr_list);

    status = lag_api->create_lag_member(&lag_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return lag_member_oid_out;
  }

  void sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = lag_api->remove_lag_member((sai_object_id_t)lag_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_member_attribute(const sai_thrift_object_id_t lag_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_lag_member_attributes(attr_vec, &sai_attr);

    status = lag_api->set_lag_member_attribute((sai_object_id_t)lag_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_lag_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t lag_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_lag_member_attributes(attr_list_vec, sai_attr_list);

    status = lag_api->get_lag_member_attribute((sai_object_id_t)lag_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec(&macsec_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_oid_out;
  }

  void sai_thrift_remove_macsec(const sai_thrift_object_id_t macsec_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec((sai_object_id_t)macsec_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_attribute(const sai_thrift_object_id_t macsec_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_attributes(attr_vec, &sai_attr);

    status = macsec_api->set_macsec_attribute((sai_object_id_t)macsec_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_attribute((sai_object_id_t)macsec_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_port_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_port(&macsec_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_port_oid_out;
  }

  void sai_thrift_remove_macsec_port(const sai_thrift_object_id_t macsec_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_port((sai_object_id_t)macsec_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_port_attribute(const sai_thrift_object_id_t macsec_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_port_attributes(attr_vec, &sai_attr);

    status = macsec_api->set_macsec_port_attribute((sai_object_id_t)macsec_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_port_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_port_attribute((sai_object_id_t)macsec_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_port_stats((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_port_stats_ext((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_port_stats(const sai_thrift_object_id_t macsec_port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_port_stats((sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_flow(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_flow_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_flow_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_flow(&macsec_flow_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_flow_oid_out;
  }

  void sai_thrift_remove_macsec_flow(const sai_thrift_object_id_t macsec_flow_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_flow((sai_object_id_t)macsec_flow_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_flow_attribute(const sai_thrift_object_id_t macsec_flow_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_flow_attributes(attr_vec, &sai_attr);

    status = macsec_api->set_macsec_flow_attribute((sai_object_id_t)macsec_flow_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_flow_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_flow_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_flow_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_flow_attribute((sai_object_id_t)macsec_flow_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_flow_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_flow_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_flow_stats((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_flow_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_flow_stats_ext((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_flow_stats(const sai_thrift_object_id_t macsec_flow_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_flow_stats((sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sc(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sc_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sc_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_sc(&macsec_sc_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_sc_oid_out;
  }

  void sai_thrift_remove_macsec_sc(const sai_thrift_object_id_t macsec_sc_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_sc((sai_object_id_t)macsec_sc_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sc_attribute(const sai_thrift_object_id_t macsec_sc_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_sc_attributes(attr_vec, &sai_attr);

    status = macsec_api->set_macsec_sc_attribute((sai_object_id_t)macsec_sc_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_sc_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_sc_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_sc_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_sc_attribute((sai_object_id_t)macsec_sc_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sc_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sc_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sc_stats((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sc_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sc_stats_ext((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sc_stats(const sai_thrift_object_id_t macsec_sc_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_sc_stats((sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sa(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sa_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sa_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_sa(&macsec_sa_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return macsec_sa_oid_out;
  }

  void sai_thrift_remove_macsec_sa(const sai_thrift_object_id_t macsec_sa_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_sa((sai_object_id_t)macsec_sa_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sa_attribute(const sai_thrift_object_id_t macsec_sa_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_macsec_sa_attributes(attr_vec, &sai_attr);

    status = macsec_api->set_macsec_sa_attribute((sai_object_id_t)macsec_sa_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_macsec_sa_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t macsec_sa_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_macsec_sa_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_sa_attribute((sai_object_id_t)macsec_sa_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sa_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sa_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sa_stats((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sa_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sa_stats_ext((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sa_stats(const sai_thrift_object_id_t macsec_sa_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_sa_stats((sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list, sai_attr_list);

    status = mcast_fdb_api->create_mcast_fdb_entry(&sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_mcast_fdb_entry(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    status = mcast_fdb_api->remove_mcast_fdb_entry(&sai_mcast_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mcast_fdb_entry_attribute(const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_attribute_t sai_attr;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_vec, &sai_attr);

    status = mcast_fdb_api->set_mcast_fdb_entry_attribute(&sai_mcast_fdb_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_mcast_fdb_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_mcast_fdb_entry_t& mcast_fdb_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    status = mcast_fdb_api->get_mcast_fdb_entry_attribute(&sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mcast_fdb_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t mirror_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mirror_session_attributes(attr_list, sai_attr_list);

    status = mirror_api->create_mirror_session(&mirror_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return mirror_session_oid_out;
  }

  void sai_thrift_remove_mirror_session(const sai_thrift_object_id_t mirror_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = mirror_api->remove_mirror_session((sai_object_id_t)mirror_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mirror_session_attribute(const sai_thrift_object_id_t mirror_session_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_mirror_session_attributes(attr_vec, &sai_attr);

    status = mirror_api->set_mirror_session_attribute((sai_object_id_t)mirror_session_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_mirror_session_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t mirror_session_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_mirror_session_attributes(attr_list_vec, sai_attr_list);

    status = mirror_api->get_mirror_session_attribute((sai_object_id_t)mirror_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mirror_session_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_inseg_entry(const sai_thrift_inseg_entry_t& inseg_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_inseg_entry_attributes(attr_list, sai_attr_list);

    status = mpls_api->create_inseg_entry(&sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_inseg_entry(const sai_thrift_inseg_entry_t& inseg_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    status = mpls_api->remove_inseg_entry(&sai_inseg_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_inseg_entry_attribute(const sai_thrift_inseg_entry_t& inseg_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_attribute_t sai_attr;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_inseg_entry_attributes(attr_vec, &sai_attr);

    status = mpls_api->set_inseg_entry_attribute(&sai_inseg_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_inseg_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_inseg_entry_t& inseg_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_inseg_entry_attributes(attr_list_vec, sai_attr_list);

    status = mpls_api->get_inseg_entry_attribute(&sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_inseg_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_inseg_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_inseg_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_inseg_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_inseg_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_inseg_entry_t> & inseg_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_nat_entry(const sai_thrift_nat_entry_t& nat_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_entry_attributes(attr_list, sai_attr_list);

    status = nat_api->create_nat_entry(&sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_nat_entry(const sai_thrift_nat_entry_t& nat_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    status = nat_api->remove_nat_entry(&sai_nat_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_entry_attribute(const sai_thrift_nat_entry_t& nat_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_attribute_t sai_attr;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_nat_entry_attributes(attr_vec, &sai_attr);

    status = nat_api->set_nat_entry_attribute(&sai_nat_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_nat_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_nat_entry_t& nat_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_nat_entry_attributes(attr_list_vec, sai_attr_list);

    status = nat_api->get_nat_entry_attribute(&sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_nat_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_nat_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_nat_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_nat_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_nat_entry_t> & nat_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_nat_zone_counter(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t nat_zone_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_zone_counter_attributes(attr_list, sai_attr_list);

    status = nat_api->create_nat_zone_counter(&nat_zone_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return nat_zone_counter_oid_out;
  }

  void sai_thrift_remove_nat_zone_counter(const sai_thrift_object_id_t nat_zone_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = nat_api->remove_nat_zone_counter((sai_object_id_t)nat_zone_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_zone_counter_attribute(const sai_thrift_object_id_t nat_zone_counter_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_nat_zone_counter_attributes(attr_vec, &sai_attr);

    status = nat_api->set_nat_zone_counter_attribute((sai_object_id_t)nat_zone_counter_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_nat_zone_counter_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t nat_zone_counter_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_nat_zone_counter_attributes(attr_list_vec, sai_attr_list);

    status = nat_api->get_nat_zone_counter_attribute((sai_object_id_t)nat_zone_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_zone_counter_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& neighbor_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_neighbor_entry_attributes(attr_list, sai_attr_list);

    status = neighbor_api->create_neighbor_entry(&sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& neighbor_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    status = neighbor_api->remove_neighbor_entry(&sai_neighbor_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_neighbor_entry_attribute(const sai_thrift_neighbor_entry_t& neighbor_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_attribute_t sai_attr;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_neighbor_entry_attributes(attr_vec, &sai_attr);

    status = neighbor_api->set_neighbor_entry_attribute(&sai_neighbor_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_neighbor_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_neighbor_entry_t& neighbor_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_neighbor_entry_attributes(attr_list_vec, sai_attr_list);

    status = neighbor_api->get_neighbor_entry_attribute(&sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_neighbor_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_all_neighbor_entries() {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = neighbor_api->remove_all_neighbor_entries(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_attributes(attr_list, sai_attr_list);

    status = next_hop_api->create_next_hop(&next_hop_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_oid_out;
  }

  void sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_api->remove_next_hop((sai_object_id_t)next_hop_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_attribute(const sai_thrift_object_id_t next_hop_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_attributes(attr_vec, &sai_attr);

    status = next_hop_api->set_next_hop_attribute((sai_object_id_t)next_hop_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_attributes(attr_list_vec, sai_attr_list);

    status = next_hop_api->get_next_hop_attribute((sai_object_id_t)next_hop_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_attributes(attr_list, sai_attr_list);

    status = next_hop_group_api->create_next_hop_group(&next_hop_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_group_oid_out;
  }

  void sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t next_hop_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_group_api->remove_next_hop_group((sai_object_id_t)next_hop_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_attribute(const sai_thrift_object_id_t next_hop_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_group_attributes(attr_vec, &sai_attr);

    status = next_hop_group_api->set_next_hop_group_attribute((sai_object_id_t)next_hop_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_group_attributes(attr_list_vec, sai_attr_list);

    status = next_hop_group_api->get_next_hop_group_attribute((sai_object_id_t)next_hop_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_member_attributes(attr_list, sai_attr_list);

    status = next_hop_group_api->create_next_hop_group_member(&next_hop_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return next_hop_group_member_oid_out;
  }

  void sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t next_hop_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_group_api->remove_next_hop_group_member((sai_object_id_t)next_hop_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_member_attribute(const sai_thrift_object_id_t next_hop_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_next_hop_group_member_attributes(attr_vec, &sai_attr);

    status = next_hop_group_api->set_next_hop_group_member_attribute((sai_object_id_t)next_hop_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_next_hop_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t next_hop_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_next_hop_group_member_attributes(attr_list_vec, sai_attr_list);

    status = next_hop_group_api->get_next_hop_group_member_attribute((sai_object_id_t)next_hop_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t policer_oid_out = SAI_NULL_OBJECT_ID;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_policer_attributes(attr_list, sai_attr_list);

    status = policer_api->create_policer(&policer_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return policer_oid_out;
  }

  void sai_thrift_remove_policer(const sai_thrift_object_id_t policer_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = policer_api->remove_policer((sai_object_id_t)policer_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_policer_attribute(const sai_thrift_object_id_t policer_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_policer_attributes(attr_vec, &sai_attr);

    status = policer_api->set_policer_attribute((sai_object_id_t)policer_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_policer_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t policer_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_policer_attributes(attr_list_vec, sai_attr_list);

    status = policer_api->get_policer_attribute((sai_object_id_t)policer_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_policer_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_policer_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = policer_api->get_policer_stats((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_policer_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = policer_api->get_policer_stats_ext((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_policer_stats(const sai_thrift_object_id_t policer_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = policer_api->clear_policer_stats((sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_attributes(attr_list, sai_attr_list);

    status = port_api->create_port(&port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_oid_out;
  }

  void sai_thrift_remove_port(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_attributes(attr_vec, &sai_attr);

    status = port_api->set_port_attribute((sai_object_id_t)port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_attribute((sai_object_id_t)port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_stats((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_stats_ext((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_stats(const sai_thrift_object_id_t port_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = port_api->clear_port_stats((sai_object_id_t)port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->clear_port_all_stats((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_pool(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_pool_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_pool_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_pool(&port_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_pool_oid_out;
  }

  void sai_thrift_remove_port_pool(const sai_thrift_object_id_t port_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port_pool((sai_object_id_t)port_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_pool_attribute(const sai_thrift_object_id_t port_pool_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_pool_attributes(attr_vec, &sai_attr);

    status = port_api->set_port_pool_attribute((sai_object_id_t)port_pool_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_pool_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_pool_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_pool_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_pool_attribute((sai_object_id_t)port_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_pool_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_pool_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_pool_stats((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_pool_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_pool_stats_ext((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_pool_stats(const sai_thrift_object_id_t port_pool_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = port_api->clear_port_pool_stats((sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_serdes(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_serdes_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_serdes_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_serdes(&port_serdes_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_serdes_oid_out;
  }

  void sai_thrift_remove_port_serdes(const sai_thrift_object_id_t port_serdes_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port_serdes((sai_object_id_t)port_serdes_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_serdes_attribute(const sai_thrift_object_id_t port_serdes_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_serdes_attributes(attr_vec, &sai_attr);

    status = port_api->set_port_serdes_attribute((sai_object_id_t)port_serdes_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_serdes_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_serdes_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_serdes_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_serdes_attribute((sai_object_id_t)port_serdes_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_serdes_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_connector(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_connector_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_connector_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_connector(&port_connector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return port_connector_oid_out;
  }

  void sai_thrift_remove_port_connector(const sai_thrift_object_id_t port_connector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port_connector((sai_object_id_t)port_connector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_connector_attribute(const sai_thrift_object_id_t port_connector_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_port_connector_attributes(attr_vec, &sai_attr);

    status = port_api->set_port_connector_attribute((sai_object_id_t)port_connector_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_port_connector_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t port_connector_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_port_connector_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_connector_attribute((sai_object_id_t)port_connector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_connector_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t qos_map_oid_out = SAI_NULL_OBJECT_ID;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_qos_map_attributes(attr_list, sai_attr_list);

    status = qos_map_api->create_qos_map(&qos_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return qos_map_oid_out;
  }

  void sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = qos_map_api->remove_qos_map((sai_object_id_t)qos_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_qos_map_attribute(const sai_thrift_object_id_t qos_map_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_qos_map_attributes(attr_vec, &sai_attr);

    status = qos_map_api->set_qos_map_attribute((sai_object_id_t)qos_map_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_qos_map_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t qos_map_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_qos_map_attributes(attr_list_vec, sai_attr_list);

    status = qos_map_api->get_qos_map_attribute((sai_object_id_t)qos_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_qos_map_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_queue(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t queue_oid_out = SAI_NULL_OBJECT_ID;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_queue_attributes(attr_list, sai_attr_list);

    status = queue_api->create_queue(&queue_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return queue_oid_out;
  }

  void sai_thrift_remove_queue(const sai_thrift_object_id_t queue_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = queue_api->remove_queue((sai_object_id_t)queue_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_queue_attributes(attr_vec, &sai_attr);

    status = queue_api->set_queue_attribute((sai_object_id_t)queue_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_queue_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t queue_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_queue_attributes(attr_list_vec, sai_attr_list);

    status = queue_api->get_queue_attribute((sai_object_id_t)queue_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_queue_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_queue_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = queue_api->get_queue_stats((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_queue_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = queue_api->get_queue_stats_ext((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_queue_stats(const sai_thrift_object_id_t queue_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = queue_api->clear_queue_stats((sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_route_entry(const sai_thrift_route_entry_t& route_entry, const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_route_entry_attributes(attr_list, sai_attr_list);

    status = route_api->create_route_entry(&sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_route_entry(const sai_thrift_route_entry_t& route_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    status = route_api->remove_route_entry(&sai_route_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_route_entry_attribute(const sai_thrift_route_entry_t& route_entry, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_attribute_t sai_attr;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_route_entry_attributes(attr_vec, &sai_attr);

    status = route_api->set_route_entry_attribute(&sai_route_entry, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_route_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_route_entry_t& route_entry, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_route_entry_attributes(attr_list_vec, sai_attr_list);

    status = route_api->get_route_entry_attribute(&sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_route_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_route_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_route_entry(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_route_entry_attribute(std::vector<sai_thrift_status_t> & object_statuses_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_attribute_t> & attr_list, const sai_thrift_bulk_op_error_mode_t mode) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_route_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const std::vector<sai_thrift_route_entry_t> & route_entry, const std::vector<sai_thrift_uint32_t> & attr_count, const sai_thrift_attribute_list_t& attr_list, const sai_thrift_bulk_op_error_mode_t mode, const std::vector<sai_thrift_status_t> & object_statuses) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t router_interface_oid_out = SAI_NULL_OBJECT_ID;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_router_interface_attributes(attr_list, sai_attr_list);

    status = router_interface_api->create_router_interface(&router_interface_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return router_interface_oid_out;
  }

  void sai_thrift_remove_router_interface(const sai_thrift_object_id_t router_interface_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = router_interface_api->remove_router_interface((sai_object_id_t)router_interface_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_router_interface_attribute(const sai_thrift_object_id_t router_interface_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_router_interface_attributes(attr_vec, &sai_attr);

    status = router_interface_api->set_router_interface_attribute((sai_object_id_t)router_interface_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_router_interface_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t router_interface_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_router_interface_attributes(attr_list_vec, sai_attr_list);

    status = router_interface_api->get_router_interface_attribute((sai_object_id_t)router_interface_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_router_interface_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_router_interface_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = router_interface_api->get_router_interface_stats((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all router_interface stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_router_interface_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = router_interface_api->get_router_interface_stats_ext((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all router_interface stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_router_interface_stats(const sai_thrift_object_id_t router_interface_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = router_interface_api->clear_router_interface_stats((sai_object_id_t)router_interface_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_attributes(attr_list, sai_attr_list);

    status = rpf_group_api->create_rpf_group(&rpf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return rpf_group_oid_out;
  }

  void sai_thrift_remove_rpf_group(const sai_thrift_object_id_t rpf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = rpf_group_api->remove_rpf_group((sai_object_id_t)rpf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_attribute(const sai_thrift_object_id_t rpf_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_rpf_group_attributes(attr_vec, &sai_attr);

    status = rpf_group_api->set_rpf_group_attribute((sai_object_id_t)rpf_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_rpf_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t rpf_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_rpf_group_attributes(attr_list_vec, sai_attr_list);

    status = rpf_group_api->get_rpf_group_attribute((sai_object_id_t)rpf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_member_attributes(attr_list, sai_attr_list);

    status = rpf_group_api->create_rpf_group_member(&rpf_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return rpf_group_member_oid_out;
  }

  void sai_thrift_remove_rpf_group_member(const sai_thrift_object_id_t rpf_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = rpf_group_api->remove_rpf_group_member((sai_object_id_t)rpf_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_member_attribute(const sai_thrift_object_id_t rpf_group_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_rpf_group_member_attributes(attr_vec, &sai_attr);

    status = rpf_group_api->set_rpf_group_member_attribute((sai_object_id_t)rpf_group_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_rpf_group_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t rpf_group_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_rpf_group_member_attributes(attr_list_vec, sai_attr_list);

    status = rpf_group_api->get_rpf_group_member_attribute((sai_object_id_t)rpf_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_samplepacket(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t samplepacket_oid_out = SAI_NULL_OBJECT_ID;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_samplepacket_attributes(attr_list, sai_attr_list);

    status = samplepacket_api->create_samplepacket(&samplepacket_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return samplepacket_oid_out;
  }

  void sai_thrift_remove_samplepacket(const sai_thrift_object_id_t samplepacket_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = samplepacket_api->remove_samplepacket((sai_object_id_t)samplepacket_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_samplepacket_attribute(const sai_thrift_object_id_t samplepacket_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_samplepacket_attributes(attr_vec, &sai_attr);

    status = samplepacket_api->set_samplepacket_attribute((sai_object_id_t)samplepacket_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_samplepacket_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t samplepacket_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_samplepacket_attributes(attr_list_vec, sai_attr_list);

    status = samplepacket_api->get_samplepacket_attribute((sai_object_id_t)samplepacket_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_samplepacket_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_oid_out = SAI_NULL_OBJECT_ID;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_attributes(attr_list, sai_attr_list);

    status = scheduler_api->create_scheduler(&scheduler_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return scheduler_oid_out;
  }

  void sai_thrift_remove_scheduler(const sai_thrift_object_id_t scheduler_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = scheduler_api->remove_scheduler((sai_object_id_t)scheduler_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_attribute(const sai_thrift_object_id_t scheduler_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_scheduler_attributes(attr_vec, &sai_attr);

    status = scheduler_api->set_scheduler_attribute((sai_object_id_t)scheduler_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_scheduler_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t scheduler_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_scheduler_attributes(attr_list_vec, sai_attr_list);

    status = scheduler_api->get_scheduler_attribute((sai_object_id_t)scheduler_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_scheduler_group_api_t *scheduler_group_api;

    status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_group_attributes(attr_list, sai_attr_list);

    status = scheduler_group_api->create_scheduler_group(&scheduler_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return scheduler_group_oid_out;
  }

  void sai_thrift_remove_scheduler_group(const sai_thrift_object_id_t scheduler_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;

    status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = scheduler_group_api->remove_scheduler_group((sai_object_id_t)scheduler_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_group_attribute(const sai_thrift_object_id_t scheduler_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_scheduler_group_api_t *scheduler_group_api;

    status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_scheduler_group_attributes(attr_vec, &sai_attr);

    status = scheduler_group_api->set_scheduler_group_attribute((sai_object_id_t)scheduler_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_scheduler_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t scheduler_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;

    status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_scheduler_group_attributes(attr_list_vec, sai_attr_list);

    status = scheduler_group_api->get_scheduler_group_attribute((sai_object_id_t)scheduler_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_segmentroute_sidlist(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t segmentroute_sidlist_oid_out = SAI_NULL_OBJECT_ID;
    sai_segmentroute_api_t *segmentroute_api;

    status = sai_api_query(SAI_API_SEGMENTROUTE, (void **)&segmentroute_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_segmentroute_sidlist_attributes(attr_list, sai_attr_list);

    status = segmentroute_api->create_segmentroute_sidlist(&segmentroute_sidlist_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return segmentroute_sidlist_oid_out;
  }

  void sai_thrift_remove_segmentroute_sidlist(const sai_thrift_object_id_t segmentroute_sidlist_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_segmentroute_api_t *segmentroute_api;

    status = sai_api_query(SAI_API_SEGMENTROUTE, (void **)&segmentroute_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = segmentroute_api->remove_segmentroute_sidlist((sai_object_id_t)segmentroute_sidlist_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_segmentroute_sidlist_attribute(const sai_thrift_object_id_t segmentroute_sidlist_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_segmentroute_api_t *segmentroute_api;

    status = sai_api_query(SAI_API_SEGMENTROUTE, (void **)&segmentroute_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_segmentroute_sidlist_attributes(attr_vec, &sai_attr);

    status = segmentroute_api->set_segmentroute_sidlist_attribute((sai_object_id_t)segmentroute_sidlist_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_segmentroute_sidlist_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t segmentroute_sidlist_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_segmentroute_api_t *segmentroute_api;

    status = sai_api_query(SAI_API_SEGMENTROUTE, (void **)&segmentroute_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_segmentroute_sidlist_attributes(attr_list_vec, sai_attr_list);

    status = segmentroute_api->get_segmentroute_sidlist_attribute((sai_object_id_t)segmentroute_sidlist_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_segmentroute_sidlist_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_oid_out = SAI_NULL_OBJECT_ID;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_attributes(attr_list, sai_attr_list);

    status = stp_api->create_stp(&stp_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return stp_oid_out;
  }

  void sai_thrift_remove_stp(const sai_thrift_object_id_t stp_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = stp_api->remove_stp((sai_object_id_t)stp_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_attribute(const sai_thrift_object_id_t stp_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_stp_attributes(attr_vec, &sai_attr);

    status = stp_api->set_stp_attribute((sai_object_id_t)stp_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_stp_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t stp_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_stp_attributes(attr_list_vec, sai_attr_list);

    status = stp_api->get_stp_attribute((sai_object_id_t)stp_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_port_attributes(attr_list, sai_attr_list);

    status = stp_api->create_stp_port(&stp_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return stp_port_oid_out;
  }

  void sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = stp_api->remove_stp_port((sai_object_id_t)stp_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_port_attribute(const sai_thrift_object_id_t stp_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_stp_port_attributes(attr_vec, &sai_attr);

    status = stp_api->set_stp_port_attribute((sai_object_id_t)stp_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_stp_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t stp_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_stp_port_attributes(attr_list_vec, sai_attr_list);

    status = stp_api->get_stp_port_attribute((sai_object_id_t)stp_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_switch_register_read(std::vector<sai_thrift_uint32_t> & reg_val_out, const sai_thrift_uint64_t platform_context, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_register_write(const sai_thrift_uint64_t platform_context, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr, const std::vector<sai_thrift_uint32_t> & reg_val) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_read(std::vector<sai_thrift_uint32_t> & reg_val_out, const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr) {

    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_write(const sai_thrift_uint32_t device_addr, const sai_thrift_uint32_t start_reg_addr, const std::vector<sai_thrift_uint32_t> & reg_val) {

    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_id_out = SAI_NULL_OBJECT_ID;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_attributes(attr_list, sai_attr_list);

    status = switch_api->create_switch(&switch_id_out, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    // switch_id is stored in the global variable
    switch_id = switch_id_out;    return switch_id_out;
  }

  void sai_thrift_remove_switch() {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = switch_api->remove_switch(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_switch_attributes(attr_vec, &sai_attr);

    status = switch_api->set_switch_attribute(switch_id, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_switch_attributes(attr_list_vec, sai_attr_list);

    status = switch_api->get_switch_attribute(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_switch_stats(std::vector<sai_thrift_uint64_t> & counters_out, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = switch_api->get_switch_stats(switch_id, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_switch_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = switch_api->get_switch_stats_ext(switch_id, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_switch_stats(const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = switch_api->clear_switch_stats(switch_id, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch_tunnel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_tunnel_oid_out = SAI_NULL_OBJECT_ID;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_tunnel_attributes(attr_list, sai_attr_list);

    status = switch_api->create_switch_tunnel(&switch_tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return switch_tunnel_oid_out;
  }

  void sai_thrift_remove_switch_tunnel(const sai_thrift_object_id_t switch_tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = switch_api->remove_switch_tunnel((sai_object_id_t)switch_tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_switch_tunnel_attribute(const sai_thrift_object_id_t switch_tunnel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_switch_tunnel_attributes(attr_vec, &sai_attr);

    status = switch_api->set_switch_tunnel_attribute((sai_object_id_t)switch_tunnel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_switch_tunnel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t switch_tunnel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_switch_tunnel_attributes(attr_list_vec, sai_attr_list);

    status = switch_api->get_switch_tunnel_attribute((sai_object_id_t)switch_tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_tunnel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_system_port(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t system_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_system_port_attributes(attr_list, sai_attr_list);

    status = system_port_api->create_system_port(&system_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return system_port_oid_out;
  }

  void sai_thrift_remove_system_port(const sai_thrift_object_id_t system_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = system_port_api->remove_system_port((sai_object_id_t)system_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_system_port_attribute(const sai_thrift_object_id_t system_port_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_system_port_attributes(attr_vec, &sai_attr);

    status = system_port_api->set_system_port_attribute((sai_object_id_t)system_port_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_system_port_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t system_port_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_system_port_attributes(attr_list_vec, sai_attr_list);

    status = system_port_api->get_system_port_attribute((sai_object_id_t)system_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_system_port_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam(&tam_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_oid_out;
  }

  void sai_thrift_remove_tam(const sai_thrift_object_id_t tam_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam((sai_object_id_t)tam_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tam_attribute(const sai_thrift_object_id_t tam_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_attribute((sai_object_id_t)tam_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_attribute((sai_object_id_t)tam_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_math_func(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_math_func_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_math_func_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_math_func(&tam_math_func_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_math_func_oid_out;
  }

  void sai_thrift_remove_tam_math_func(const sai_thrift_object_id_t tam_math_func_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_math_func((sai_object_id_t)tam_math_func_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_math_func_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_math_func_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_math_func_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_math_func_attribute((sai_object_id_t)tam_math_func_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_math_func_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_math_func_attribute(const sai_thrift_object_id_t tam_math_func_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_math_func_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_math_func_attribute((sai_object_id_t)tam_math_func_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_threshold(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_threshold_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_threshold_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event_threshold(&tam_event_threshold_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_threshold_oid_out;
  }

  void sai_thrift_remove_tam_event_threshold(const sai_thrift_object_id_t tam_event_threshold_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_event_threshold((sai_object_id_t)tam_event_threshold_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_threshold_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_threshold_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_threshold_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_event_threshold_attribute((sai_object_id_t)tam_event_threshold_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_threshold_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_threshold_attribute(const sai_thrift_object_id_t tam_event_threshold_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_threshold_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_event_threshold_attribute((sai_object_id_t)tam_event_threshold_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_int(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_int_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_int_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_int(&tam_int_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_int_oid_out;
  }

  void sai_thrift_remove_tam_int(const sai_thrift_object_id_t tam_int_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_int((sai_object_id_t)tam_int_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_int_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_int_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_int_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_int_attribute((sai_object_id_t)tam_int_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_int_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_int_attribute(const sai_thrift_object_id_t tam_int_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_int_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_int_attribute((sai_object_id_t)tam_int_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_tel_type(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_tel_type_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_tel_type_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_tel_type(&tam_tel_type_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_tel_type_oid_out;
  }

  void sai_thrift_remove_tam_tel_type(const sai_thrift_object_id_t tam_tel_type_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_tel_type((sai_object_id_t)tam_tel_type_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_tel_type_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_tel_type_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_tel_type_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_tel_type_attribute((sai_object_id_t)tam_tel_type_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_tel_type_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_tel_type_attribute(const sai_thrift_object_id_t tam_tel_type_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_tel_type_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_tel_type_attribute((sai_object_id_t)tam_tel_type_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_report(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_report_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_report_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_report(&tam_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_report_oid_out;
  }

  void sai_thrift_remove_tam_report(const sai_thrift_object_id_t tam_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_report((sai_object_id_t)tam_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_report_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_report_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_report_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_report_attribute((sai_object_id_t)tam_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_report_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_report_attribute(const sai_thrift_object_id_t tam_report_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_report_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_report_attribute((sai_object_id_t)tam_report_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_telemetry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_telemetry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_telemetry_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_telemetry(&tam_telemetry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_telemetry_oid_out;
  }

  void sai_thrift_remove_tam_telemetry(const sai_thrift_object_id_t tam_telemetry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_telemetry((sai_object_id_t)tam_telemetry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_telemetry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_telemetry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_telemetry_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_telemetry_attribute((sai_object_id_t)tam_telemetry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_telemetry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_telemetry_attribute(const sai_thrift_object_id_t tam_telemetry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_telemetry_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_telemetry_attribute((sai_object_id_t)tam_telemetry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_transport(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_transport_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_transport_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_transport(&tam_transport_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_transport_oid_out;
  }

  void sai_thrift_remove_tam_transport(const sai_thrift_object_id_t tam_transport_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_transport((sai_object_id_t)tam_transport_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_transport_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_transport_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_transport_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_transport_attribute((sai_object_id_t)tam_transport_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_transport_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_transport_attribute(const sai_thrift_object_id_t tam_transport_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_transport_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_transport_attribute((sai_object_id_t)tam_transport_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_collector(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_collector_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_collector_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_collector(&tam_collector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_collector_oid_out;
  }

  void sai_thrift_remove_tam_collector(const sai_thrift_object_id_t tam_collector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_collector((sai_object_id_t)tam_collector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_collector_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_collector_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_collector_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_collector_attribute((sai_object_id_t)tam_collector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_collector_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_collector_attribute(const sai_thrift_object_id_t tam_collector_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_collector_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_collector_attribute((sai_object_id_t)tam_collector_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_action(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_action_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_action_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event_action(&tam_event_action_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_action_oid_out;
  }

  void sai_thrift_remove_tam_event_action(const sai_thrift_object_id_t tam_event_action_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_event_action((sai_object_id_t)tam_event_action_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_action_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_action_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_action_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_event_action_attribute((sai_object_id_t)tam_event_action_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_action_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_action_attribute(const sai_thrift_object_id_t tam_event_action_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_action_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_event_action_attribute((sai_object_id_t)tam_event_action_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event(&tam_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tam_event_oid_out;
  }

  void sai_thrift_remove_tam_event(const sai_thrift_object_id_t tam_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_event((sai_object_id_t)tam_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tam_event_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tam_event_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_event_attribute((sai_object_id_t)tam_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_attribute(const sai_thrift_object_id_t tam_event_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tam_event_attributes(attr_vec, &sai_attr);

    status = tam_api->set_tam_event_attribute((sai_object_id_t)tam_event_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel_map(&tunnel_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_map_oid_out;
  }

  void sai_thrift_remove_tunnel_map(const sai_thrift_object_id_t tunnel_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_map((sai_object_id_t)tunnel_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_attribute(const sai_thrift_object_id_t tunnel_map_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_map_attributes(attr_vec, &sai_attr);

    status = tunnel_api->set_tunnel_map_attribute((sai_object_id_t)tunnel_map_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_map_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_map_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_map_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_map_attribute((sai_object_id_t)tunnel_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel(&tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_oid_out;
  }

  void sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel((sai_object_id_t)tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_attributes(attr_vec, &sai_attr);

    status = tunnel_api->set_tunnel_attribute((sai_object_id_t)tunnel_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_attribute((sai_object_id_t)tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_tunnel_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = tunnel_api->get_tunnel_stats((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_tunnel_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = tunnel_api->get_tunnel_stats_ext((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_tunnel_stats(const sai_thrift_object_id_t tunnel_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = tunnel_api->clear_tunnel_stats((sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_term_table_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_term_table_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel_term_table_entry(&tunnel_term_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_term_table_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_term_table_entry(const sai_thrift_object_id_t tunnel_term_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_term_table_entry((sai_object_id_t)tunnel_term_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_term_table_entry_attribute(const sai_thrift_object_id_t tunnel_term_table_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_vec, &sai_attr);

    status = tunnel_api->set_tunnel_term_table_entry_attribute((sai_object_id_t)tunnel_term_table_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_term_table_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_term_table_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_term_table_entry_attribute((sai_object_id_t)tunnel_term_table_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_term_table_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map_entry(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_entry_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel_map_entry(&tunnel_map_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return tunnel_map_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_map_entry(const sai_thrift_object_id_t tunnel_map_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_map_entry((sai_object_id_t)tunnel_map_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_entry_attribute(const sai_thrift_object_id_t tunnel_map_entry_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_tunnel_map_entry_attributes(attr_vec, &sai_attr);

    status = tunnel_api->set_tunnel_map_entry_attribute((sai_object_id_t)tunnel_map_entry_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tunnel_map_entry_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t tunnel_map_entry_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_tunnel_map_entry_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_map_entry_attribute((sai_object_id_t)tunnel_map_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_entry_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_attributes(attr_list, sai_attr_list);

    status = udf_api->create_udf(&udf_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_oid_out;
  }

  void sai_thrift_remove_udf(const sai_thrift_object_id_t udf_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf((sai_object_id_t)udf_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_attribute(const sai_thrift_object_id_t udf_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_attributes(attr_vec, &sai_attr);

    status = udf_api->set_udf_attribute((sai_object_id_t)udf_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_attribute((sai_object_id_t)udf_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_match(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_match_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_match_attributes(attr_list, sai_attr_list);

    status = udf_api->create_udf_match(&udf_match_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_match_oid_out;
  }

  void sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf_match((sai_object_id_t)udf_match_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_match_attribute(const sai_thrift_object_id_t udf_match_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_match_attributes(attr_vec, &sai_attr);

    status = udf_api->set_udf_match_attribute((sai_object_id_t)udf_match_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_match_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_match_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_match_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_match_attribute((sai_object_id_t)udf_match_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_match_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_group(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_group_attributes(attr_list, sai_attr_list);

    status = udf_api->create_udf_group(&udf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return udf_group_oid_out;
  }

  void sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf_group((sai_object_id_t)udf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_group_attribute(const sai_thrift_object_id_t udf_group_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_udf_group_attributes(attr_vec, &sai_attr);

    status = udf_api->set_udf_group_attribute((sai_object_id_t)udf_group_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_udf_group_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t udf_group_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_udf_group_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_group_attribute((sai_object_id_t)udf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_group_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t virtual_router_oid_out = SAI_NULL_OBJECT_ID;
    sai_virtual_router_api_t *virtual_router_api;

    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_virtual_router_attributes(attr_list, sai_attr_list);

    status = virtual_router_api->create_virtual_router(&virtual_router_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return virtual_router_oid_out;
  }

  void sai_thrift_remove_virtual_router(const sai_thrift_object_id_t virtual_router_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *virtual_router_api;

    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = virtual_router_api->remove_virtual_router((sai_object_id_t)virtual_router_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_virtual_router_attribute(const sai_thrift_object_id_t virtual_router_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_virtual_router_api_t *virtual_router_api;

    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_virtual_router_attributes(attr_vec, &sai_attr);

    status = virtual_router_api->set_virtual_router_attribute((sai_object_id_t)virtual_router_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_virtual_router_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t virtual_router_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *virtual_router_api;

    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_virtual_router_attributes(attr_list_vec, sai_attr_list);

    status = virtual_router_api->get_virtual_router_attribute((sai_object_id_t)virtual_router_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_virtual_router_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_oid_out = SAI_NULL_OBJECT_ID;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_attributes(attr_list, sai_attr_list);

    status = vlan_api->create_vlan(&vlan_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return vlan_oid_out;
  }

  void sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = vlan_api->remove_vlan((sai_object_id_t)vlan_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_vlan_attributes(attr_vec, &sai_attr);

    status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vlan_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t vlan_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_vlan_attributes(attr_list_vec, sai_attr_list);

    status = vlan_api->get_vlan_attribute((sai_object_id_t)vlan_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_member_attributes(attr_list, sai_attr_list);

    status = vlan_api->create_vlan_member(&vlan_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return vlan_member_oid_out;
  }

  void sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = vlan_api->remove_vlan_member((sai_object_id_t)vlan_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_member_attribute(const sai_thrift_object_id_t vlan_member_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_vlan_member_attributes(attr_vec, &sai_attr);

    status = vlan_api->set_vlan_member_attribute((sai_object_id_t)vlan_member_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_vlan_member_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t vlan_member_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_vlan_member_attributes(attr_list_vec, sai_attr_list);

    status = vlan_api->get_vlan_member_attribute((sai_object_id_t)vlan_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_member_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_vlan_stats(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = vlan_api->get_vlan_stats((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_vlan_stats_ext(std::vector<sai_thrift_uint64_t> & counters_out, const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids, const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = vlan_api->get_vlan_stats_ext((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids, (sai_stats_mode_t)mode, sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS && status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_vlan_stats(const sai_thrift_object_id_t vlan_oid, const std::vector<sai_thrift_stat_id_t> & counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids = (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    }
    else {
      return;
    }


    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = vlan_api->clear_vlan_stats((sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_wred(const std::vector<sai_thrift_attribute_t> & attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t wred_oid_out = SAI_NULL_OBJECT_ID;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_wred_attributes(attr_list, sai_attr_list);

    status = wred_api->create_wred(&wred_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);    return wred_oid_out;
  }

  void sai_thrift_remove_wred(const sai_thrift_object_id_t wred_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = wred_api->remove_wred((sai_object_id_t)wred_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_wred_attribute(const sai_thrift_object_id_t wred_oid, const sai_thrift_attribute_t& attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attr;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);

    sai_thrift_parse_wred_attributes(attr_vec, &sai_attr);

    status = wred_api->set_wred_attribute((sai_object_id_t)wred_oid, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_wred_attribute(sai_thrift_attribute_list_t& attr_list_out, const sai_thrift_object_id_t wred_oid, const sai_thrift_attribute_list_t& attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    else {
      return;
    }


    const std::vector<sai_thrift_attribute_t> &attr_list_vec = attr_list.attr_list;

    sai_thrift_parse_wred_attributes(attr_list_vec, sai_attr_list);

    status = wred_api->get_wred_attribute((sai_object_id_t)wred_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_wred_attributes(sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_query_attribute_enum_values_capability(std::vector<int32_t> & _out, const sai_thrift_object_type_t object_type, const sai_thrift_attr_id_t attr_id, const int32_t caps_count) {

    // This function should be manually implemented elsewhere
    return;
  }

  int64_t sai_thrift_object_type_get_availability(const sai_thrift_object_type_t object_type, const sai_thrift_attr_id_t attr_id, const int32_t attr_type) {

    // This function should be manually implemented elsewhere
    return 0ULL;
  }

};


